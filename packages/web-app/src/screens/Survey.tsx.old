import React, { useEffect, useState } from 'react';
import { useNavigate, useParams } from 'react-router-dom';

import { Form, Formik, FormikHelpers, FormikTouched, FormikValues } from 'formik';
import { Loader } from "@progress/kendo-react-indicators";
import { isNil, isEmpty } from 'lodash';
import * as yup from 'yup'

import Survey from '../classes/Survey';
import FieldWrapper from '../components/FieldWrapper';

import './Survey.scss';
import styled, { createGlobalStyle, DefaultTheme, ThemeProvider } from 'styled-components';
import { fordTheme } from '../themes/defaultTheme';
import LocaleString from '../classes/LocaleString';
import SurveyQuestion from '../classes/SurveyQuestion';
import SurveyResponse from '../classes/SurveyResponse';

function SurveyScreen() {
  const params = useParams();
  const [ thisSurvey, setThisSurvey ] = useState<Survey>();
  const [ thisError, setThisError ] = useState<LatitudeAPIResponse>();

  // pagination help
  const [ currentPage, setCurrentPage ] = useState<number>(0);
  const [ currentQuestions, setCurrentQuestions ] = useState<SurveyQuestion[]>([]);
  const [ isLastPage, setIsLastPage ] = useState<boolean>(false);
  
  const thisSurveyResponse = new SurveyResponse({eventID: params.eventID});

  const [ validationSchema, setValidationSchema ] = useState(yup.object().shape({}));

  const [ theme, setTheme ] = useState<DefaultTheme>(fordTheme);

  useEffect(() => {
    fetch('https://us-central1-latitude-lead-system.cloudfunctions.net/getSurvey', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({eventID: params.eventID}),
    }).then(response => {
      response.json().then((res:LatitudeAPIResponse) => {
        if (res.success) {
          setThisSurvey(new Survey(res.event));
          setIsLastPage(res.event.questions.length === 1);
          document.title = res.event.name;
          setCurrentPage(0);
        } else {
          setThisError(res);
        }
      })
    }).catch(err => {
      alert(`err`);
    });
  }, []);

  // change the page number, change the questions
  useEffect(() => {
    if (thisSurvey) {
      setCurrentQuestions(thisSurvey.questions[currentPage]);
    }
  }, [currentPage, thisSurvey]);

  // loop over and set validation
  useEffect(() => {
    const newSchemaObject: Record<string, any> = {};
    const debugSchemaObject: Record<string, string[]> = {};
    
    // strong password: /^(?=.*?[A-Z])(?=.*?[a-z])(?=.*?[0-9])(?=.*?[#?!@$%^&*-]).{8,}$/  https://uibakery.io/regex-library/password
    for (const question of currentQuestions) {
      const debugArray = [];
      // first set the base
      switch (question.type) {
        case SurveyQuestion.TYPE.EMAIL:
          // email regex just in case: /^\S+@\S+\.\S+$/
          debugArray.push('string.email');
          newSchemaObject[question.id] = yup.string().nullable().email(new LocaleString({
            en: "Invalid Email Address",
            es: "Correo Electrónico Inválida",
            fr: "Adresse e-mail invalide",
          }).toString());
          break;
        case SurveyQuestion.TYPE.BUTTON_MULTI: case SurveyQuestion.TYPE.CHECKBOX_LIST:
          debugArray.push('array');
          newSchemaObject[question.id] = yup.array(yup.string()).nullable();
          break;
        case SurveyQuestion.TYPE.PHONE:
          debugArray.push('phone');
          newSchemaObject[question.id] = yup.string().nullable().matches(/((\(\d{3}\) ?)|(\d{3}-))?\d{3}-\d{4}/, new LocaleString({
            en: "Invalid Phone Number",
            es: "Teléfono Inválido",
            fr: "S'il vous plaît entrez un numéro de téléphone valide.",
          }).toString());
          break;
        case SurveyQuestion.TYPE.ZIP:
          debugArray.push('zip');
          newSchemaObject[question.id] = yup.string().nullable().matches(/^[0-9]{5}(?:-[0-9]{4})?$/, new LocaleString({
            en: "Invalid Zip",
            es: "Código Postal Inválido",
            fr: "Code Postal Non Valide",
          }).toString());
          break;
        case SurveyQuestion.TYPE.DATE: case SurveyQuestion.TYPE.DATE_TIME:
          debugArray.push('date');
          newSchemaObject[question.id] = yup.date().nullable();
          break;
        case SurveyQuestion.TYPE.NUMERIC:
          debugArray.push('numeric');
          newSchemaObject[question.id] = yup.number().nullable();
          break;
        default:
          debugArray.push('string');
          newSchemaObject[question.id] = yup.string().nullable();
      }

      // check for required
      if (question.required) {
        debugArray.push('required');
        newSchemaObject[question.id] = newSchemaObject[question.id].required(question.requiredMessage?.toString());
      }

      question.validation?.map(v => {
        const currentSchema = newSchemaObject[question.id];

        switch(v.type) {
          // (array types)
          case 'minArray': // (must select at least X items)
            debugArray.push('minArray');
            newSchemaObject[question.id] = newSchemaObject[question.id].min(v.testValue, v.error.toString());
            break;
          case 'maxArray': // (cannot select more than X items)
            debugArray.push('maxArray');
            newSchemaObject[question.id] = newSchemaObject[question.id].max(v.testValue, v.error.toString());
            break;
          
          // (date / number)
          case 'min':
              debugArray.push('min');
              newSchemaObject[question.id] = newSchemaObject[question.id].min(v.testValue, v.error.toString());
              break;
          case 'max':
              debugArray.push('max');
              newSchemaObject[question.id] = newSchemaObject[question.id].max(v.testValue, v.error.toString());
              break;
          
          // (string)
          case 'minLength':
              debugArray.push('minLength');
              newSchemaObject[question.id] = newSchemaObject[question.id].min(v.testValue, v.error.toString());
              break;
          case 'maxLength':
              debugArray.push('maxLength');
              newSchemaObject[question.id] = newSchemaObject[question.id].max(v.testValue, v.error.toString());
              break;
          
          // (any)
          case 'requiredIfValueIs': // (this field is required if another field's value is X)
            debugArray.push('requiredIfValueIs');
            newSchemaObject[question.id] = newSchemaObject[question.id].when(v.siblingField, {
              is: v.testValue,
              then: currentSchema.required(v.error)
            })
            break;
          case 'requiredIfValueIsNot': // (this field is required if another field's value is NOT X)
            debugArray.push('requiredIfValueIsNot');
            newSchemaObject[question.id] = newSchemaObject[question.id].when(v.siblingField, {
              is: (siblingValue:any) => siblingValue !== v.testValue,
              then: currentSchema.required(v.error)
            })
            break;
          case 'requiredIfArrayIncludes': // (this field is required if another field's array includes X)
            debugArray.push('requiredIfArrayIncludes');
            newSchemaObject[question.id] = newSchemaObject[question.id].when(v.siblingField, {
              is: (siblingValue:any[]) => siblingValue.includes(v.testValue),
              then: currentSchema.required(v.error)
            })
            break;
          case 'requiredIfAnyValueExists': // (this field is required if another field has any value)
            debugArray.push('requiredIfAnyValueExists');
            newSchemaObject[question.id] = newSchemaObject[question.id].when(v.siblingField, {
              is: (siblingValue:any) => !isNil(siblingValue) && !isEmpty(siblingValue),
              then: currentSchema.required(v.error)
            })
            break;
          case 'requiredIfNoValueExists': // (this field is required if another field has no value)
            debugArray.push('requiredIfNoValueExists');
            newSchemaObject[question.id] = newSchemaObject[question.id].when(v.siblingField, {
              is: (siblingValue:any) => isNil(siblingValue) || isEmpty(siblingValue),
              then: currentSchema.required(v.error)
            })
            break;
          
          case 'mustBe': // (this field must be this value i.e. checkbox)
            debugArray.push('mustBe');
            newSchemaObject[question.id] = newSchemaObject[question.id].oneOf([v.testValue], v.error.toString());
            break;
          case 'regex': // (matches regex pattern)
            debugArray.push('regex');
            newSchemaObject[question.id] = newSchemaObject[question.id].matches(new RegExp(v.testValue), v.error.toString());
            break;
        }
      });

      debugSchemaObject[question.id] = debugArray;
    }
    
    setValidationSchema(yup.object().shape(newSchemaObject));
  }, [currentQuestions]);

  useEffect(() => {
    const newTheme:DefaultTheme = {
      ...theme,
      ...thisSurvey?.theme,
      colors: {
        ...theme.colors,
        ...thisSurvey?.theme.colors,
      }
    }

    setTheme(newTheme);
  }, [thisSurvey?.theme]);

  const navigate = useNavigate();

  const submitSurvey = async (values:FormikValues, actions:FormikHelpers<any>) => {
    // save the survey
    thisSurveyResponse.endSurvey();
    thisSurveyResponse.answers = values;

    setTimeout(() => {
      fetch('https://us-central1-latitude-lead-system.cloudfunctions.net/saveSurvey', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          eventID: params.eventID,
          survey: thisSurveyResponse.toFirestore(),
        }),
      }).then(response => {
        response.json().then((res: LatitudeAPIResponse) => {
          if (res.success) {
            navigate(`/thanks`, {state:{thanks:thisSurvey!.thanks.toString(), theme:JSON.stringify(thisSurvey!.theme)}})
          } else {
            actions.setSubmitting(false);
            alert(`${res.message}`);
          }
        })
      }).catch(err => {
        actions.setSubmitting(false);
        alert(err);
      });
    }, 500);
  }

  return (
    <Formik
      validationSchema={validationSchema}
      initialValues={{}}
      onSubmit={(
        values: FormikValues,
        actions: FormikHelpers<any>
      ) => {
        actions.setSubmitting(true);
        
        if (isLastPage) {
          submitSurvey(values, actions);
        } else {
          console.log('VALUES', values);
          // get the next page
          let nextPage = currentPage+1;

          const testPage = (testPage:number) => {
            const nextQuestions = thisSurvey!.questions[testPage];
            let visibleQuestions = 0;
            nextQuestions.map(q => q.isVisible(values) ? visibleQuestions++ : null);
            return visibleQuestions > 0;
          }
          
          // make sure the next page has any questions
          while (!testPage(nextPage)) {
            nextPage++;
            if (nextPage >= thisSurvey!.questions.length) {
              return submitSurvey(values, actions);
            }
          }
          setIsLastPage(nextPage >= thisSurvey!.questions.length - 1);
          setCurrentPage(nextPage);
          actions.resetForm({values, isSubmitting: false});
        }
      }}
      validateOnMount={false}
      validateOnBlur={true}
      validateOnChange={false}
    >{({
      isSubmitting,
      values,
      isValid,
      touched,
      submitForm,
      setFieldTouched,
    }) => {
      const doPress = () => {
        // first we validate the form
        submitForm();

        // then because the user hit submit, we "touch" every field and skip re-validating
        for (const q of currentQuestions || []) {
          setFieldTouched(q.id, true, false);
        }
      };

      return (
      <Form>
        <div className="fds-layout-grid__inner">
          {thisSurvey ? 
            <ThemeProvider theme={theme}>
              <GlobalStyle />
              <div className="fds-layout-grid__cell--span-12">
                {
                  thisSurvey.theme.micrositeHeader ?
                  <div className="fmc-billboard fmc-billboard--height-33vh fmc-billboard--justify-start fmc-billboard--align-start">
                    <img className="fmc-billboard__image" src={thisSurvey.theme.micrositeHeader.href} alt={thisSurvey.name.toString()} />
                    <div className="fmc-billboard__content">
                      <Title>{thisSurvey.name.toString()}</Title>
                    </div>
                  </div>
                  :
                  <Title>{thisSurvey.name.toString()}</Title>
                }
              </div>
              
              {currentQuestions.map(question => (
                <FieldWrapper key={question.id} question={question} values={values} />
              ))}
              
              <div className="fds-layout-grid__cell--span-12 fds-align--center">
                { isSubmitting ? 
                  <Loader type="converging-spinner" size="medium" />
                  : 
                  <SubmitButton onClick={(e) => {
                    e.preventDefault();
                    doPress();
                  }} disabled={isSubmitting} isValid={isValid} touched={touched}>{isLastPage ? 'Finish' : 'Next'}</SubmitButton>
                }
              </div>
            </ThemeProvider>
            :
            <div className="fds-layout-grid__cell--span-12 fds-align--center">
              {thisError ? <h2>{thisError.message}</h2> : <Loader type="converging-spinner" size="large" />}
            </div>
          }
        </div>
      </Form>
    )}}
  </Formik>
  );
}

interface ButtonProps {
  readonly isValid: boolean;
  readonly touched: FormikTouched<{}>;
}

// themed components
const Title = styled.h1`
  color: ${props => props.theme.colors.splashText};
  padding: 1em;
`;

const SubmitButton = styled.button<ButtonProps>`
  color: ${props => props.theme.colors.buttonText};
  background-color: ${props => props.isValid && Object.keys(props.touched).length ? props.theme.colors.valid : props.theme.colors.muted};
  border-radius: ${props => props.theme.borderRadius};
  font-size: 18px;
  font-weight: 400;
  padding: 1em;
  width: 50%;
`;

const GlobalStyle = createGlobalStyle`
  body {
    color: ${props => (props.theme.colors.text)};
    background-color: ${props => (props.theme.colors.background)};
    font-family: ${props => (props.theme.fonts?.body)};
  }
`

export default SurveyScreen;
